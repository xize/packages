#!/bin/sh /etc/rc.common
# Copyright (c) 2016-2025 Dirk Brenken (dev@brenken.org)
# This is free software, licensed under the GNU General Public License v3.

# set (s)hellcheck exceptions
# shellcheck disable=all

START=25
USE_PROCD=1

extra_command "scan" "[<radio>|<ifname>] Scan for available nearby uplinks"
extra_command "setup" "[<iface>] [<zone>] [<metric>] Setup the travelmate uplink interface, by default 'trm_wwan' with firewall zone 'wan' and metric '100'"

trm_init="/etc/init.d/travelmate"
trm_script="/usr/bin/travelmate.sh"
trm_pidfile="/var/run/travelmate.pid"
trm_scanfile="/var/run/travelmate.scan"

boot() {
	if [ -s "${trm_pidfile}" ]; then
		: >"${trm_pidfile}"
	fi
	rc_procd start_service
}

start_service() {
	if "${trm_init}" enabled; then
		if [ "${action}" = "boot" ]; then
			return 0
		fi
		procd_open_instance "travelmate"
		procd_set_param command "${trm_script}" "${@}"
		procd_set_param pidfile "${trm_pidfile}"
		procd_set_param nice "$(uci_get travelmate global trm_nice "0")"
		procd_set_param stdout 0
		procd_set_param stderr 1
		procd_close_instance
	fi
}

reload_service() {
	local ppid pid timeout

	timeout="$(uci_get travelmate global trm_timeout)"

	if [ -s "${trm_pidfile}" ]; then
		ppid="$(cat "${trm_pidfile}" 2>/dev/null)"
		if [ -n "${ppid}" ]; then
			pid="$(pgrep -xnf "sleep ${timeout:-60} 0" -P ${ppid} 2>/dev/null)"
			if [ -n "${pid}" ]; then
				kill -INT ${pid} 2>/dev/null
			fi
		fi
	fi
}

stop_service() {
	rc_procd "${trm_script}" stop
}

status_service() {
	local key keylist value rtfile

	rtfile="$(uci_get travelmate global trm_rtfile "/tmp/trm_runtime.json")"
	json_load_file "${rtfile}" >/dev/null 2>&1
	if json_select data >/dev/null 2>&1; then
		printf "%s\n" "::: travelmate runtime information"
		json_get_keys keylist
		for key in ${keylist}; do
			json_get_var value "${key}"
			printf "  + %-18s : %s\n" "${key}" "${value}"
		done
	else
		printf "%s\n" "::: no travelmate runtime information available"
	fi
}

scan() {
	local scan_dev scan_mode radio_num radio_phy radio="${1}"

	: > "${trm_scanfile}"
	scan_dev="$(ubus -S call network.wireless status 2>/dev/null | jsonfilter -ql1 -e "@.${radio}.interfaces[0].ifname")"
	if [ -z "${scan_dev}" ]; then
		radio_num="${radio//[a-z]/}"
		radio_phy="phy#${radio_num}"
		scan_dev="$(iw dev 2>/dev/null | awk -v iw_phy="${radio_phy}" '{if($0==iw_phy){inside=1;next}if(inside&&/^phy#/){exit}if(inside&&$1=="Interface"){print $2;exit}}')"
		if [ -z "${scan_dev}" ]; then
			if iw phy "phy${radio_num}" interface add "trmscan${radio_num}" type managed >/dev/null 2>&1; then
				if ip link set "trmscan${radio_num}" up >/dev/null 2>&1; then
					scan_dev="trmscan${radio_num}"
				fi
			fi
		fi
	fi
	if [ -n "${scan_dev}" ]; then
		scan_mode="$(uci_get travelmate global trm_scanmode "active")"
		[ "${scan_mode}" != "passive" ] && scan_mode=""
		printf "%b\n" "$(iw "${scan_dev}" scan ${scan_mode} 2>/dev/null |
			awk '/^BSS /{if(bssid!=""){if(ssid=="")ssid="unknown";printf "%3s %3s %17s %s %s %10s %30s %s\n",signal,channel,bssid,rsn,wpa,cipher,auth,ssid};signal="";channel="";rsn="-";wpa="-";cipher="-";auth="-";bssid=toupper(substr($2,1,17))}
			/signal:/{signal=2*($2 + 100)}
			/SSID:/{$1="";sub(/^ /,"",$0);ssid=$0}
			/freq:/{channel=int($2);if(channel>=2400&&channel<=2500)channel=int((channel-2407)/5);else if(channel>=4900&&channel<=5900)channel=int((channel-5000)/5);else if(channel>=5925&&channel<=7125)channel=int(((channel-5950)/5)+1)}
			/WPA:/{wpa="+"}
			/RSN:/{rsn="+"}
			/Group cipher:/{cipher=$4}
			/Authentication suites:/{auth="";for(i=4;i<=NF;i++){auth=auth (i==4?"":",")$i}}
			END{if(bssid!=""){if(ssid=="")ssid="unknown";printf "%3s %3s %17s %s %s %10s %30s %s\n",signal,channel,bssid,rsn,wpa,cipher,auth,ssid}}' | sort -rn)" > "${trm_scanfile}"
	fi
	if [ -n "${radio_phy}" ] && [ -n "${radio_num}" ]; then
		ip link set "trmscan${radio_num}" down >/dev/null 2>&1
		iw dev "trmscan${radio_num}" del >/dev/null 2>&1
	fi
}

setup() {
	local iface cnt=0 input="${1:-"trm_wwan"}" zone="${2:-"wan"}" metric="${3:-"100"}"

	iface="$(uci_get travelmate global trm_iface)"
	input="${input//[+*~%&\$@\"\' ]/}"
	zone="${zone//[+*~%&\$@\"\' ]/}"
	metric="${metric//[^0-9]/}"

	if [ -n "${iface}" ] && [ "${iface}" = "${input}" ]; then
		return 1
	elif [ -n "${input}" ]; then
		if [ -n "${iface}" ]; then
			uci -q batch <<-EOC
				del network."${iface}"
				del network."${iface}6"
			EOC
		fi
		uci -q batch <<-EOC
			set travelmate.global.trm_enabled="1"
			set travelmate.global.trm_iface="${input}"
			set network."${input}"="interface"
			set network."${input}".proto="dhcp"
			set network."${input}".metric="${metric}"
			set network."${input}6"=interface
			set network."${input}6".device="@${input}"
			set network."${input}6".proto="dhcpv6"
			commit travelmate
			commit network
		EOC

		while [ -n "$(uci -q get firewall.@zone["${cnt}"].name)" ]; do
			if [ "$(uci -q get firewall.@zone["${cnt}"].name)" = "${zone}" ]; then
				if [ -n "${iface}" ]; then
					uci -q batch <<-EOC
						del_list firewall.@zone["${cnt}"].network="${iface}"
						del_list firewall.@zone["${cnt}"].network="${iface}6"
					EOC
				fi
				uci -q batch <<-EOC
					add_list firewall.@zone["${cnt}"].network="${input}"
					add_list firewall.@zone["${cnt}"].network="${input}6"
					commit firewall
				EOC
				break
			fi
			cnt=$((cnt + 1))
		done

		if [ -n "${iface}" ]; then
			cnt=0
			while [ -n "$(uci -q get wireless.@wifi-iface["${cnt}"].network)" ]; do
				if [ "$(uci -q get wireless.@wifi-iface["${cnt}"].network)" = "${iface}" ]; then
					uci -q set wireless.@wifi-iface["${cnt}"].network="${input}"
				fi
				cnt=$((cnt + 1))
			done
			uci -q commit wireless
		fi
		/etc/init.d/network reload >/dev/null 2>&1
		/etc/init.d/firewall reload >/dev/null 2>&1
		"${trm_init}" restart
	fi
}

service_triggers() {
	local iface delay

	iface="$(uci_get travelmate global trm_iface)"
	delay="$(uci_get travelmate global trm_triggerdelay "2")"
	PROCD_RELOAD_DELAY=$((delay * 1000))

	if [ -n "${iface}" ]; then
		procd_add_interface_trigger "interface.*.down" "${iface}" "${trm_init}" reload
	fi
	procd_add_raw_trigger "interface.*.up" "${PROCD_RELOAD_DELAY}" "${trm_init}" start
	procd_add_config_trigger "config.change" "travelmate" "${trm_init}" restart
}
